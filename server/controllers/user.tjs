var db = require(global.DIR_SERVER + '/db.tjs'),
    bcrypt = require('bcrypt');

function validatePhone(phone) {
}

function validateEmail(email) {
}

function defaults(defaults, given) {
  var ob = {};

  for (var i in defaults) {
    if (given[i]) {
      ob[i] = given[i];
    }
    else if (defaults[i] !== null) {
      ob[i] = defaults[i];
    }
  }

  return ob;
}

exports.index = function (options, callback) {
  console.log(options);
  await {
    db.getCollection('users', defer(users, client));
  }
  await {
    users.count(defer(e, count));
    users.find().toArray(defer(e2, results));
  }
  console.log(results);
  callback(count.toString() + ' users');
};

exports.create = function (options, callback) {
  var client, users, finder, count, errorType;

  var user = defaults({
    username: 'Specter',
    // Facebook Login info
    fbid: '',
    accessToken: '',
    expires: '',
    // If not using Facebook, provide password
    password: 'password',
    // Either email or phone is required
    email: '',
    phone: '123-456-7890',
    image: '',
  }, options);
  
  // Check if all facebook access info is provided
  if (!user.fbid && !user.accessToken && !user.expires) {
    // Check if a password is provided
    if (user.password) {
      var pwd = user.password;
      // Hash password using bcrypt
      await {
        bcrypt.gen_salt(10, defer(err, salt));
      }
      await {
        bcrypt.encrypt(pwd, salt, defer(err, hash));
      }
      user.password = hash;
    } else {
      return callback({e: 1, msg: 'Please provide a password or ' +
                                  'a facebook access token'});
    }
  }
  
  // user creation requires email or phone
  if (!user.email && !user.phone) {
    return callback({e: 2, msg: 'Please specify an email or phone.'});
  }

  // format some data
  if (user.phone) {
    user.phone = parseInt(user.phone, 10);
  }
  
  console.log(user);

  await {
    db.getCollection('users', defer(users, client));
  }

  if (user.email) {
    finder = users.find({email: user.email});
    errorType = 'email';
  }
  else {
    finder = users.find({phone: user.phone});
    errorType = 'phone';
  }
 
  await {
    finder.count(defer(e, count));
  } 

  if (count > 0) {
    client.close();
    return callback({e: 3, msg: 'There is already a user with that ' + errorType + '.'});
  }

  await {
    users.insert(user, defer(e, stuff));
  } 

  console.log(e, stuff)

  client.close();
  return callback({e: 0, msg: 'Success'});
};


exports.authenticate = function (options, callback) {
  
  await {
    this.get(options, defer(query));
  }
  var user = query.user;
  console.log(user);
  
  var testpass = 'password';

  await {
    bcrypt.compare(testpass, user.password, defer(err, res));
  }
  
  if (res) {
    return callback({e: 0, msg: 'Authenticated!'});
  } else {
    return callback({e: 1, msg: 'Username and password do not match.'});
  }

};


exports.get = function (options, callback) {
  var user = defaults({
    _id: null,
    email: null,
    phone: null 
  }, options);

  if (!user._id && !user.email && !user.phone) {
    return callback({e:1, msg: 'You must specify an index.'});
  }
  
  // Format phone # query correctly
  if (user.phone) {
    var intPhone = parseInt(user.phone, 10);
    user.phone = intPhone;
  }

  var client, users, e, list;

  await {
    db.getCollection('users', defer(users, client));
  }
  await {
    users.find(user).toArray(defer(e, list));
  }

  if (list.length) {
    callback({e: 0, user: list[0]});
  }
  else {
    callback({e: 2, msg: 'No user found'});
  }

  client.close();
};

